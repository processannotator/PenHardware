<link rel="import" href="../bower_components/polymer/polymer.html">

<dom-module id="render-view">

	<template>
	<style is="custom-style">
	:host {
		margin: 0;
		cursor: -webkit-grab;
	}

	:host.track {
		cursor: -webkit-grabbing;
	}



	:host:hover {}

	canvas {
		width: 100%;
		height: 100%;
	}

	:host.polygonCursor {
		cursor: crosshair;

	}
		</style>

	</template>

	<script>

	createArrow = function (point, multFactor) {
		var material = new THREE.LineBasicMaterial({
			color: 0xdd8822
		})

		var geometry = new THREE.Geometry();
		geometry.vertices.push(
			point,
			point.multiplyScalar(multFactor),
			new THREE.Vector3( 10, 0, 0 )
		)

		return new THREE.Line( geometry, material )
	}


	// FIXME: shouldnt those global variables better reside inside the element
	// vis this.glRenderer = ...
	var glScene = new THREE.Scene()
	var cssScene = new THREE.Scene()
	var camera
	var controls
	var cssObject
	var glRenderer
	var cube
	var cssRenderer
	var render
	var animate

	Polymer({
		is: "render-view",
		properties: {
			model: Object,
			annotations: {
				type: Array,
				observer: "updateAnnotations"
			}
		},
		listeners: {
			'up': 'toggleTrack',
			'down': 'toggleTrack',
			'mousemove': 'mouseMoved',
			'tap': 'tap'
		},

		ready: function() {
			// doesnt work with listeners on this very element
			// so create start event listener
			console.log('ready!!!')
			document.addEventListener('keydown', this.keydown.bind(this))
		},
		animate: function() {
			requestAnimationFrame(this.animate.bind(this))
			controls.update()
		},
		render: function() {
			glRenderer.render(glScene, camera)
			cssRenderer.render(cssScene, camera)
		},
		attached: function() {

			this.modus = {tool: '', modelGrabbing: false}

			// the render-view is interested in the state of the tool-box selector
			// lets add the event listener then
			var toolBox = Polymer.dom(this.parent).querySelector('#tool-box')
			if (toolBox) {
				toolBox.addEventListener('iron-select', this.toolChanged.bind(this))
			} else {
				console.error('tool-box no found inside renderViews attached function. Maybe use different way to use toolbox?');
			}


			let width = this.parentNode.getBoundingClientRect().width
			let height = this.parentNode.getBoundingClientRect().height

			camera = new THREE.PerspectiveCamera(45, width / height, 0.1, width * 50)
			camera.position.set(800, 800, 800)

			glRenderer = new THREE.WebGLRenderer({
				antialias: true,
				alpha: true
			})
			glRenderer.setClearColor(0x00ff00, 0.0)
			glRenderer.setSize(width, height)

			// let both renderers/canvases overlap
			glRenderer.domElement.style.position = 'absolute';
			glRenderer.domElement.style.top = 0;

			cssRenderer = new THREE.CSS3DRenderer()
			cssRenderer.setSize(width, height)

			// create group for text annotations in 3D
			this.labelGroup = new THREE.Object3D()
			console.log('the annotation group:')
			console.log(this)
			console.log(this.labelGroup)
			cssScene.add(this.labelGroup)

			// setup 3d-controls (rotating the camera with cursor)
			controls = new THREE.TrackballControls(camera, this)

			controls.rotateSpeed = 1.0
			controls.zoomSpeed = 1.2
			controls.panSpeed = 0.8

			controls.noZoom = false
			controls.noPan = false

			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3
			controls.keys = [65, 83, 68]

			var geometry = new THREE.BoxGeometry(700, 700, 700)
			var material = new THREE.MeshNormalMaterial({
				transparent: false,
				opacity: 1.0,
				side: THREE.DoubleSide
			})

			cube = new THREE.Mesh(geometry, material)

			var sphereGeometry = new THREE.SphereGeometry( 20, 16, 16 )
			var sphereMaterial = new THREE.MeshBasicMaterial( {color: 0xff0000} )
			this.pointerSphere = new THREE.Mesh( sphereGeometry, sphereMaterial )

			glScene.add(cube)
			glScene.add(this.pointerSphere)

			// create Raycaster used for polygon editing tool
			this.raycaster = new THREE.Raycaster()


			glRenderer.domElement.id = 'glRenderer'
			cssRenderer.domElement.id = 'cssRenderer'
			Polymer.dom(this.root).appendChild(glRenderer.domElement)
			Polymer.dom(this.root).appendChild(cssRenderer.domElement)
			controls.addEventListener('change', this.render.bind(this))
			controls.addEventListener('change', this.updateAnnotationVisibility.bind(this))

			controls.handleResize()

			this.render()
			this.animate()
		},
		resize: function(event) {
			let width = this.parentNode.getBoundingClientRect().width
			let height = this.parentNode.getBoundingClientRect().height
			glRenderer.setSize(width, height)
			cssRenderer.setSize(width, height)
			camera.aspect = width / height
			camera.updateProjectionMatrix()
			controls.handleResize()
			this.render()
		},

		updateAnnotations: function() {
			// debug output of annotations
			console.log(this.labelGroup)
			// first remove all previous annotations
			// FIXME: only update modified ones, instead of removing and completely re-creating
			for (let child of this.labelGroup.children) {
				this.labelGroup.remove(child)
			}

			for (let annotation of this.annotations) {
				doc = annotation.doc

				let div = document.createElement('div')
				let textElement = document.createElement('span')
				div.style.opacity = '0.85'
				div.style.fontSize = '40px'
				div.style.padding = "0.35em"
				div.style.background = "rgb(255, 255, 255)"
				div.style.border = "rgb(247, 156, 62) solid 0.125em"
				div.style.transition = "opacity 0.5s"
				div.innerHTML = doc.description
				div.addEventListener('mouseover', () => console.log('over'))

				let multFactor = 2
				let label = new THREE.CSS3DSprite(div)
				label.position.set(
					doc.position[0] * multFactor,
					doc.position[1] * multFactor,
					doc.position[2] * multFactor)

					// TODO: add arrow, label to a group/structure to be selectable
				let arrow = createArrow(
					new THREE.Vector3(doc.position[0], doc.position[1], doc.position[2]),
					 multFactor)
				glScene.add(arrow)
				this.labelGroup.add(label)
			}

			this.render()

		},
		updateAnnotationVisibility: function () {
			// triggered on controls update
			let raycaster = new THREE.Raycaster()

			for(let label of this.labelGroup.children) {
				let normalizedDirection = (label.position.clone().sub(camera.position)).normalize()
				raycaster.set(camera.position.clone(), normalizedDirection)
				raycaster.far = camera.position.distanceTo(label.position)
				let intersections = raycaster.intersectObject(cube)
				if(intersections.length !== 0) {
					label.element.style.opacity = 0.0
				} else {
					label.element.style.opacity = 0.8
				}


			}
			this.render()

		},
		toggleTrack: function(e) {
			this.modus.modelGrabbing = !this.modus.modelGrabbing
			Polymer.dom(this).classList.toggle('track')
		},
		updateMouse: function (mouseEvent) {
			let canvas = this.$$('canvas')
			this.mouse = new THREE.Vector2(
				(mouseEvent.layerX / canvas.width) * 2 - 1,
				-((mouseEvent.layerY / canvas.height) * 2 - 1)
			)
		},
		mouseMoved: function (e) {

			if(this.modus.tool === 'polygon') {

				this.updateMouse(e)
				this.raycaster.setFromCamera(this.mouse, camera)
				let intersections = this.raycaster.intersectObject(cube)

				if(intersections.length !== 0){
					if(this.modus.modelGrabbing === false)
						Polymer.dom(this).classList.add('polygonCursor')
					this.pointerSphere.position.set(intersections[0].point.x, intersections[0].point.y , intersections[0].point.z)
					this.render()
				} else {
					Polymer.dom(this).classList.remove('polygonCursor')
				}
			}
		},
		keydown: function (e) {
			if (event.defaultPrevented) {
				return; // Should do nothing if the key event was already consumed.
			}
			switch (e.keyIdentifier) {
				case 'Enter':
					console.log('enter??')
					if(this.modus.tool === 'polygon'){
						// TODO: finish shape and create annotation
						console.log('pressed enter in polygon mode')
						addAnnotation({
							description: 'new polygon...',
							polygon: this.verticesPolygonTool,
							position: [
								this.verticesPolygonTool[0].x,
								this.verticesPolygonTool[0].y,
								this.verticesPolygonTool[0].z
							]
						}).then(() => {
							this.verticesPolygonTool = []
							console.log('added polygon annotation')
						})
					}
					break;
				default:

			}

		},
		tap: function(e) {
			console.log(this.modus.tool)
			switch (this.modus.tool) {
				case 'polygon':

					this.updateMouse(e.detail.sourceEvent)

					// update the picking ray with the camera and mouse position
					this.raycaster.setFromCamera(this.mouse, camera);

					// calculate objects intersecting the picking ray
					// only use the frontmost intersection  -> [0]
					var intersections = this.raycaster.intersectObjects(glScene.children)
					var intersection = ( intersections.length ) > 0 ? intersections[ 0 ] : null
					this.verticesPolygonTool.push(intersection.point)

					// create new preview polygon/shape when enough points are available
					if(this.verticesPolygonTool.length >= 3) {
							glScene.remove(this.previewPolygon)
							this.previewPolygon = this.polygonFromPoints(this.verticesPolygonTool, 0x00ff00)
							glScene.add(this.previewPolygon)

					}
					this.render()


				break;
				default:

			}

		},
		polygonFromPoints: function (vertices, color) {
			// IDEA: move to helper object?
			let polygon = new THREE.Geometry()
			polygon.vertices = vertices

			// calculate faces of preview polygon
			for (var i = 1; i < polygon.vertices.length - 1; i++) {
				polygon.faces.push( new THREE.Face3( 0, i, i+1 ) )
			}

			polygon.computeBoundingSphere()

				return new THREE.Mesh(
					polygon,
					new THREE.MeshBasicMaterial( {
						color: color,
						side: THREE.DoubleSide
					} )
				)
		},

		toolChanged: function(e) {
			// this is render-view's event listener on the toolBox
			// when a different tool is selected, this function is triggered

			//do some cleanup/inits
			glScene.remove(this.previewPolygon)
			this.previewPolygon = undefined
			this.verticesPolygonTool = []

			// set this.modus.tool to the tool clicked in the box
			this.modus.tool = e.target.selected
			console.log(this.modus.tool)

			switch (this.modus.tool) {
				case 'polygon':

					break;
				default:

			}

			console.log(this.modus.tool)
		}

	})
	</script>

</dom-module>
